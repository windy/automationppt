
<!DOCTYPE html>
<meta charset="utf-8" />
<title>自动化测试技术 by WinDy(yafei Lee) (made with impress.js presentation tool by
  Bartek Szopka @bartaz, fork from Mariusz Nowak @medikoo)</title>

<link rel="stylesheet" href="css/font.css" />
<link rel="stylesheet" href="css/default.css" />
<link rel="stylesheet" href="highlight/styles/sunburst.css">

<div id="impress" class="impress-not-supported">
  <div id="fm1" class="fallback-message hidden">
    <p>Your browser <b>doesn't support the features required</b> by impress.js,
      so you are presented with a simplified version of this presentation.</p>
    <p>For the best experience please use the latest <b>Chrome</b> or
      <b>Safari</b> browser. Firefox 10 (to be released soon)
      will also handle it.</p>
  </div>
  <div id="fm2" class="fallback-message">
    <p>If you have fast machine and recent Google Chrome or Safari installed,
      please check <a href="3d/index.html">a bit more "moving" version of that presentation</a></p>
    <p style="text-align:center"><big>Otherwise, scroll down to see the slides</big></p>
  </div>

  <div id="asynchronous-javascript" class="step">
    <h1>自动化<br/>测试技术</h1>
    <p class="footer">
      <a href="http://200.200.0.35:88/">交流平台</a> ·
      <span>2012年3月31号</span> ·
      <span><a href="http://windy.github.com/">WinDy(yafei Lee)</a></span>
    </p>
  </div>
  <div id="why-asynchronous" class="step">
    <h2>为什么有自动化测试 ?</h2>
  </div>

  <div id="client-side" class="step">
    <h3>自动化测试产生的目的</h3>
    <p class="substep">显而易见:</p>
    <p class="substep">我们需要更快的开发软件 (<b>using Automation Testing</b>)</p>
    <p class="substep">我们不需要每次都靠人验证重复的功能点</p>
    <p class="substep">机器可靠又准确</p>
  </div>

  <div id="server-side" class="step">
    <h3>自动化测试能达到的效果</h3>
    <p class="substep">适当的投入能够有效节省测试成本</p>
    <p class="substep">让开发人员更快速更有信心<b>重构</b>代码</p>
    <p class="substep">持续集成，测试驱动</p>
  </div>

  <div id="why-asynchronous-on-server-side" class="step">
    <h2>什么是 <span>自动化测试技术</span> ？</h2>
  </div>

  <div id="its-about-external-resources" class="step">
    <h3>自动化测试技术与测试自动化技术</h3>
    <p>自动化工具不等同于自动化技术</p>
    <p class="substep"><b>它是一系列开发与测试技术的结合</b></p>
    <p class="substep">它包含了与开发过程截然不同的理念与框架</p>
    <p class="substep">测试自动化与自动化测试可以认为等同（虽然有一定差别）</p>
  </div>

  <div id="how-much-waiting-can-cost" class="step">
    <h3>自动化测试包含的理念 ？</h3>
    <p>高效，重复，维护</p>
    <ul>
      <li>开发效率大于执行效率</li>
      <li>可复用性</li>
      <li>可维护性</li>
      <li>技术选型只有更合适，没有最优</li>
    </ul>
  </div>

  <div id="better-software-can-multitask" class="step">
    <h3>自动化测试技术选型</h3>
    <div class="substep">
      <p>动态语言优先：我们选择了Ruby作为主要开发语言，代码简洁，易于上手，表达能力强</p>
      <pre><code>File.open("test.txt","w") { |f| f.puts("hello world")  }</code></pre>
      <p>将 "hello world" 写入一个文件</p>
    </div>
    <div class="substep">
      <p style="margin-top:0.9em">计算1到100的和</p>
      <pre><code>(1..100).inject(&:+)</code></pre>
      <p>将 1加到100，利用inject的代码块进行调用，可见直观简洁</p>
    </div>
  </div>

  <div id="how-io-should-be-done" class="step">
    <h3>自动化测试技术选型(2)</h3>
    <div class="substep">
    <p>只选合适的，我们也使用C/C++/BASH/TCL等做自动化</p>
    </div>
    <div class="substep">
      <li>LR的脚本开发，使用LR-Like的C接口</li>
      <li>UI自动化，我们使用<strong><a href="http://watir.com">Watir</a></strong>库，Ruby语言</li>
      <li>Mips与TestCenter自动化控制，我们使用<strong>TCL</strong>脚本</li>
      <li>控制我们设备后台，我们使用<strong>net-ssh</strong>并封装接口</li>
      <li>模拟用户登录，配置参数，我们使用<strong>patron</strong>库</li>
    </div>
  </div>

  <div id="how-to-write-asynchronous-code" class="step">
    <h3 class="lone">怎么去选择 ?</h3>
  </div>

  <div id="nodejs-convention" class="step">
    <p>快速开发</p>
  </div>

  <div id="exercise" class="step">
    <p><q>与被测系统技术相符</q></p>
  </div>

  <div id="exercise-nodejs" class="step">
    <h3>选择开源，成熟稳定</h3>
  </div>

  <div id="exercise-node-comment" class="step">
    <p>没有最好的，只有最合适的</p>
    <ul>
      <li>投入产出</li>
      <li>可测试性</li>
      <li>折中选择</li>
    </ul>
  </div>

  <div id="most-popular-solutions" class="step">
    <h3>Sangfor自动化成熟方案介绍：</h3>
    <ul>
      <li class="substep" data-order="0">AC_BVT 自动化技术分析 <a href="http://windy.github.com">svn</a></li>
      <li class="substep" data-order="1">SSLWeb自动化技术分析 <a href="http://windy.github.com">svn</a></li>
      <li class="substep" data-order="2">AC_GUI自动化技术分析 <a href="http://windy.github.com">svn</a></li>
      <li class="substep" data-order="3">Apm2.0bvt自动化技术分析 <a href="http://windy.github.com">svn</a></li>
      <li class="substep" data-order="4">其他常见技术整合 <a href="http://windy.github.com">svn</a></li>
      <li class="empty substep" data-order="5"><a>...</a></li>
      <li class="substep" data-order="5">Sangfor自动化测试框架介绍</li>
    </ul>
  </div>

  <div id="it-can-be-done-better-than-that" class="step smaller">
    <h3>AC_BVT 自动化技术分析</h3>
    <p class="substep"><b>ATT框架：关键字驱动，便于开发与维护，ATM平台，便于管理与结果分析</b></p>
    <p class="substep">Watir</p>
    <p class="substep"><b>Patron</b></p>
    <p class="substep">AutoIT</p>
    <p class="substep"></p>
    <p class="substep"><b></b></p>
  </div>

  <div id="deferred-promise" class="step">
    <h2>Deferred / Promise</h2>
  </div>

  <div id="what-is-deferred" class="step">
    <h3 class="lone">What is Deferred ?</h3>
  </div>

  <div id="deferred" class="step smaller">
    <p>Deferred holds both <b>resolver</b> and <b>promise</b> objects</p>
    <p style="text-align: center"><img src="deferred.png" /></p>
    <p class="substep">Observers interested in value are attached to <b>promise</b> object</p>
    <p class="substep">With <b>resolver</b> we resolve <b>promise</b> with actual value</p>
    <p class="small substep">In some other implementations of deferred there is no distinction between deferred and a promise, it's the same object. In <a href="https://github.com/kriskowal/q">Q</a> and <a href="https://github.com/medikoo/deferred">deferred</a> it's different</p>
    <p class="substep">In common usage <b>promise</b> is returned to the world and <b>resolver</b> is kept internally</p>
  </div>

  <div id="deferred-example" class="step smaller">
    <h3>Example</h3>
    <p class="substep"><q><code>delay</code> function decorator. Decorates function so its execution is delayed in time</q></p>
    <pre class="substep"><code style="font-size: 0.75em">var delay = function (fn, timeout) {
  return function () {
  <span class="substep">  var <mark>d = deferred()</mark>, self = this, args = arguments;</span>

  <span class="substep">  setTimeout(function () {
      <mark>d.resolve(fn.apply(self, args))</mark>;
    }, timeout);</span>

<span class="substep">    <mark>return d.promise</mark>;</span>
  };
};

<span class="substep">var delayedAdd = delay(function (a, b) {
    return a + b;
}, 100);</span>

<span class="substep">var result = delayedAdd(2, 3);
deferred.isPromise(result); // true</span>

<span class="substep">result.then(function (value) {
  // Invoked after 100 milliseconds
  console.log(value); // 5
});</span></code></pre>
  </div>

  <div id="what-is-a-promise" class="step">
    <h3 class="lone">What is a Promise ?</h3>
  </div>

  <div id="promise" class="step">
    <p style="text-align: center"><img src="littlecalculist.promises.png" /></p>
    <p class="substep" style="text-align: center"><img src="kriskowal.promises.png" /></p>
    <p class="substep">... ok, maybe let's try plain English ;)</p>
    <p class="substep"><b>Promise is an object that represents eventual value which may already be available or is expected to be available in a future.</b></p>
    <p class="substep"><b>Promise may succeed (fulfillment) or fail (rejection)</b></p>
    <p class="substep"><b>Promise can be resolved only once</b></p>
  </div>

  <div id="attaching-observers" class="step">
    <h3>Attaching observers</h3>
    <pre class="substep"><code>promise.then(onsuccess, onerror);</code></pre>
    <p class="substep"><b>Both callbacks are optional</b>. You can provide either <code>onsucess</code> or <code>onerror</code></p>
    <p class="substep"><b>Callbacks are called only once (only either onsuccess or onerror is called)</b></p>
    <div class="substep">
      <p>In <a href="https://github.com/medikoo/deferred">deferred</a> implementation <code>promise</code> equals <code>promise.then</code> function, so you may use <code>promise</code> directly:</p>
      <pre><code>console.log(promise === promise.then); // true
promise(onsuccess, onerror);</code></pre>
    </div>
  </div>

  <div id="chaining-promises" class="step">
    <h3>Chaining promises</h3>
    <p class="substep">Promises by nature can be chained</p>
    <div class="substep">
      <p><b><code>promise</code> function returns another promise</b> which is resolved with a value returned by a callback function:</p>
      <pre><code>delayedAdd(2, 3)(function (result) {
  // result === 5
  return result*result;
})<span class="substep">(function (result) {
  console.log(result); // 25
});</span></code></pre>
    </div>
  </div>

  <div id="chaining-promises-cont" class="step">
    <p>If no callback for given flow (success or error) was given, then promise is resolved with input value:</p>
    <pre><code>delayedAdd(2, 3)(null, function (err) {
  // handle eventual error
})(function (result) {
  console.log(result); // 5
});</code></pre>
    <div class="substep">
      <p>Instead of callbacks <b>you can also pass promise values to promise</b>:</p>
      <pre><code>promise3 = promise1(promise2);
// promise3 is resolved with the value of promise2 ...
// ... when both promise1 and promise2 are resolved</code></pre>
    </div>
  </div>

  <div id="nesting-promises" class="step">
    <h3>Nesting promises</h3>
    <div class="substep">
      <p>If a promise is resolved with another promise, it's not really resolved. <b>Promise is resolved only when the final promise is resolved with a real value:</b></p>
      <pre><code>var d = deferred();
d.resolve(delayedAdd(2, 3));
d.promise(function (result) {
  console.log(5); // 5;
});</code></pre>
    </div>
  </div>

  <div id="error-handling" class="step">
    <h3>Error handling</h3>
    <p class="substep"><b>Errors in promises are handled in a separate flow</b></p>
    <div class="substep">
      <p><b>A promise resolved with an error (rejected) propagates its error to all promises that depend on this promise</b> (e.g. promises initiated by adding observers)</p>
      <pre><code style="font-size: 0.8em">var error = new Error("Error");
promise(function () {
  // success flow
  throw error; // caught by promise implementation
})<span class="substep">(function () {
  // never called
})</span><span class="substep">(function () {
  // never called
}, function (e) {
  console.log(e === error); // true
  // handle error
});</span></code></pre>
    </div>
  </div>

  <div id="end" class="step smaller">
    <p>When there's no error callback passed, eventual error is silent</p>
    <div class="substep">
      <p>To expose the error, end promise chain with <code>.end()</code>:</p>
      <pre><code style="font-size: 0.8em">promise(function () {
  throw new Error("Error"); // caught
})(function () {
  // never called
}).end(); // Error is thrown</code></pre>
    </div>
    <p class="substep"><strong>It's very important to end promise chains with <code>end</code> otherwise eventual errors that were not handled will not be exposed</strong></p>
    <div class="substep">
      <p>Errors can also be handled via <code>end</code> call:</p>
      <pre><code style="font-size: 0.8em">promise(function () {
  // ...
}).end(function(err) {
  // handle error
});</code></pre>
    </div>
  </div>

  <div id="promisify" class="step">
    <h3>Working with Node.js callback style functions</h3>
    <p class="substep">It's not convienient to work with both promises and callback style functions</p>
    <p class="substep">When you decide to build your flow with promises <b>don't mix both concepts just <i>promisify</i> asynchronous functions</b> so they return promises instead.</p>
    <div class="substep">
      <p>Do that with <b><code>deferred.promisify</code></b>:</p>
      <pre><code>var readFile = deferred.promisify(fs.readFile);
readFile(filename, 'utf-8')(function (content) {
  // process content
}).end();</code></pre>
    </div>
  </div>
  <div id="promisify-cont" class="step">
    <p><code>deferred.promisify</code> also takes care of input arguments. <b>It makes sure that all arguments that are to be passed to asynchronous function are first resolved</b>.</p>
    <div class="substep">
      <p>So we can write constructs like this:</p>
      <pre><code>var readFile = deferred.promisify(fs.readFile)
  , writeFile = deferred.promisify(fs.writeFile);

writeFile(filename + '.copy',
  readFile(filename, 'utf-8')).end();</code></pre>
    </div>
    <p class="small substep"><i>but keep in mind it's not best real world example, don't copy files that way, use <code>fs.createReadStream</code> instead</i></p>
  </div>

  <div id="grouping-promises" class="step">
    <h3>Grouping promises</h3>
    <p class="substep">Sometimes we're interested in results of more than one promise object</p>
    <div class="substep">
      <p>We can help us again with a deferred function:</p>
      <pre><code>deferred(delayedAdd(2, 3), delayedAdd(3, 5),delayedAdd(1, 7))(
    function (result) {
        console.log(result); // [5, 8, 8]
    }
);</code></pre>
    </div>
  </div>

  <div id="processing-collections" class="step smaller">
    <h3>Processing collections</h3>
    <div class="substep">
      <p>There is promise aware Array's <code>map</code>:</p>
      <pre><code>deferred.map(filenames, readFile)(function (result) {
  // result is an array of files content
});</code></pre>
    </div>
    <p class="substep">If any call of <code>readFile</code> ends with an error, then promise returned by <code>deferred.map</code> is immediately rejected with that error</p>
    <div class="substep">
      <p>There's also promise aware Array's <code>reduce</code>:</p>
      <pre><code>deferred.reduce([delayedAdd(2, 3), delayedAdd(3, 5), delayedAdd(1, 7)],
  function (a, b) {
    return delayedAdd(a, b);
  })(function (result) {
  console.log(result); // 21
});</code></pre>
    </div>
  </div>

  <div id="promise-extensions" class="step">
    <h3>Promise extensions</h3>
    <p class="substep">In <a href="https://github.com/medikoo/deferred">deferred</a> promises are equipped with some useful extensions:</p>
    <h4 class="substep"><code>map</code> & <code>reduce</code></h4>
    <div class="substep">
      <p>Promise aware Array's methods that would be executed on resolved value</p>
      <pre><code>readdir(directory).map(readFile)(function (result) {
  // result is an array of directory files content
});</code></pre>
    </div>
  </div>

  <div id="invoke" class="step">
    <h4><code>invoke</code></h4>
    <div class="substep">
      <p>Invokes function (with pregiven arguments) on resolved value.</p>
      <pre><code>promise = deferred({ foo: function (arg) { return arg*arg }});
promise.invoke('foo', 3)(function (result) {
  console.log(result); // 9
});</code></pre>
    </div>
    <div class="substep">
      <p>It works also with asynchronous functions:</p>
      <pre><code>promise = deferred({ foo: function (arg, callback) {
  setTimeout(function () {
    callback(null, arg*arg);
  }, 100);
} });
promise.invoke('foo', 3)(function (result) {
  console.log(result); // 9
});</code></pre>
    </div>
  </div>

  <div id="match" class="step">
    <h4><code>match</code></h4>
    <div class="substep">
      <p>Matches resolved list into function arguments</p>
      <pre><code>var promise = deferred([2, 3]);
promise.match(function (a, b) {
  console.log(a + b); // 5
});</code></pre>
    </div>
    <p class="substep">For more extensions see documentation at <a href="https://github.com/medikoo/deferred">github.com/medikoo/deferred</a></p>
    <p class="substep"><b>You can also freely extend <a href="https://github.com/medikoo/deferred">deferred</a> with your own extensions</b></p>
  </div>

  <div id="example-promises" class="step">
    <p>We've been introduced to promises. Let's look back at our Node.js example</p>
    <div class="abs-box">
      <pre class="base substep hide-on-notsupported" data-order="0" style="font-size:0.3em;"><code>// Read all filenames in given path
readdir(dirname, function (err, filenames) {
  var result, waiting;
  if (err) {
    // Handle eventual error
    return;
  }
  // Filter *.js filenames
  filenames = files.filter(function (filename) {
    return (filename.slice(-3) === '.js') && (filename !== 'lib.js');
  });
  // Read content of each file
  waiting = 0;
  result = [];
  filenames.forEach(function (filename, index) {
    ++waiting;
    readFile(filename, 'utf8', function (err, content) {
      if (err) {
        // Handle eventual error
        return;
      }
      result[index] = content;
      if (!--waiting) {
        // Got content of all files, concatenate and write into lib.js
        writeFile(dirname + '/lib.js', result.join("\n"), function (err) {
          if (err) {
            // Handle eventual error
            return;
          }
        });
      }
    });
  });
});</code></pre>
      <div class="substep keep" data-order="1">
        <p>With promises we can write it nearly same way as wrote it initially:</p>
        <pre><code style="font-size: 0.8em"><span class="substep" data-order="6">writeFile(dirname + '/lib.js',</span>
<span class="substep" data-order="2">  // Read all filenames in given path
  readdir(dirname)</span>
<span class="substep" data-order="3">  // Filter *.js filenames
  .invoke('filter', function (filename) {
    return (filename.slice(-3) === '.js')
      && (filename !== 'lib.js');
  })</span>
<span class="substep" data-order="4">  // Read content of each file
  .map(function (filename) {
    return readFile(filename, 'utf-8');
  })</span>
<span class="substep" data-order="5">  // Concatenate into one string
  .invoke('join', '\n')</span>
<span class="substep" data-order="6">)</span><span class="substep" data-order="7">.end(function (err) {
  // handle eventual error
});</span></code></pre>
      </div>
    </div>
  </div>

  <div id="future" class="step smaller">
    <h3>What future standards have to offer ?</h3>
    <p class="substep">Currently there are no plans for promise implementation in Harmony</p>
    <p class="substep"><b>What's interesting we can find promises in Dart</b></p>
    <p class="substep">However its API is not as versatile and largly differs form what was introduced here</p>
    <ul>
      <li class="substep">Instead of two possible resolution states there are three: completed, cancelled & failed</li>
      <li class="substep">You need to use three different methods to attach observers</li>
      <li class="substep">If promise is resolved with another promise, you need to run <code>flatten</code> to get final real value</li>
      <li class="substep">Different approach to grouping promises (join and waitFor methods)</li>
    </ul>
    <p class="substep">See Dart spec for more info on that: <a href="http://api.dartlang.org/dart_core/Promise.html">http://api.dartlang.org/dart_core/Promise.html</a></p>
    <p class="substep">Let's see what <b>real</b> future has to offer...</p>
  </div>

  <div id="coroutines" class="step smaller">
    <h3>Harmony</h3>
    <p>There are no promises but is there anything else that can help us with asynchronous programming ?</p>
    <h3 class="substep">Coroutines</h3>
    <div class="substep">
      <p>They would help with callback style, as instead of:</p>
      <pre><code>readFile(filename, function (err, content) {
  // ..
});</code></pre>
    </div>
    <div class="substep">
      <p>It would be possible to keep flow in current scope:</p>
      <pre><code>[err, content] = yield readFile(filename);
if (err) {
  // handle error
  return;
}
// process content</code></pre>
    </div>
    <p class="substep"><b>This however won't work well with promises<br />(what about error path?)</b></p>
  </div>

  <div id="proxies" class="step">
    <h3>Proxies</h3>
    <p class="substep">Proxies are very powerful</p>
    <p class="substep"><b>With proxies we can proxy property names onto resolved promise values</b></p>
    <div class="substep">
      <p>So instead of:</p>
      <pre><code>promise.invoke('foo', arg);</code></pre>
    </div>
    <div class="substep">
      <p>We would be able to write:</p>
      <pre><code>promise.foo(arg);</code></pre>
    </div>
    <p class="substep"><b>With internal support from promise implementation this would work</b></p>
  </div>

  <div id="example-proxies" class="step">
    <p>Let's improve our example with proxies.</p>
    <div class="abs-box">
      <div class="substep hide-on-notsupported">
        <p style="margin-top:0; visibility: hidden">It's basically same as our first "synchronous" version:</p>
        <pre><code>writeFile(dirname + '/lib.js',
  // Read all filenames in given path
  readdir(dirname)
  // Filter *.js filenames
  .invoke('filter', function (filename) {
    return (filename.slice(-3) === '.js')
      && (filename !== 'lib.js');
  })
  // Read content of each file
  .map(function (filename) {
    return readFile(filename, 'utf-8');
  })
  // Concatenate into one string
  .invoke('join', '\n')
).end(function (err) {
  // handle eventual error
});</code></pre>
      </div>
      <div class="substep base">
        <p>It's basically same as our first "synchronous" version:</p>
    <pre><code>writeFile(dirname + '/lib.js',
  // Read all filenames in given path
  readdir(dirname)
  // Filter *.js filenames
  .filter(function (filename) {
    return (filename.slice(-3) === '.js')
      && (filename !== 'lib.js');
  })
  // Read content of each file
  .map(<mark>function (filename) {
    return readFile(filename, 'utf-8');
  }</mark>)
  // Concatenate into one string
  .join('\n')
)<mark>.end(function (err) {
  // handle eventual error
})</mark>;</code></pre>
      </div>
    </div>
  </div>

  <div id="questions" class="step">
    <h2>Questions ?</h2>
  </div>

  <div id="thank-you" class="step final">
    <h2>Thank you !</h2>

    <p class="name">Mariusz Nowak</p>
    <p class="email"><a href="mailto:mariusz@medikoo.com">mariusz@medikoo.com</a></p>
    <p class="twitter p-a"><a href="https://twitter.com/medikoo"><img src="twitter.png" /> @medikoo</a></p>
    <p class="github p-a"><a href="https://github.com/medikoo"><img src="github.png" /> github.com/medikoo</a></p>
    <p class="deferred p-a"><a href="https://github.com/medikoo/deferred">github.com/medikoo/deferred</a><br />
<b>npm install deferred</b></p>

  </div>

  <div id="overview" class="step" data-x="3400" data-y="2000" data-scale="10"></div>
  <div class="hint"><p>Use a spacebar or arrow keys to navigate</p></div>
</div>

<div id="timer"></div>

<script src="highlight/highlight.pack.js"></script>
<script src="js/impress.js"></script>
<script src="js/default.js"></script>
</body>
</html>
